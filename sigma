

-- i have this open source so you can take anything from this cuz i did get the gui from exuny

--------------------------------------------------------------------------------------------------
 --may take some time to load also!


--change close keybind cuz its bugged























                                                                                                                                               



























local loadstring, game, getgenv, setclipboard = loadstring, game, getgenv, setclipboard



if getgenv().Aimbot then return end


loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Aimbot-V2/main/Resources/Scripts/Raw%20Main.lua"))()



local Aimbot = getgenv().Aimbot
local Settings, FOVSettings, Functions = Aimbot.Settings, Aimbot.FOVSettings, Aimbot.Functions

local Library = loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)() -- Pepsi's UI Library

local Parts = {"Head", "HumanoidRootPart", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg", "UpperTorso", "LeftUpperLeg", "RightFoot", "RightLowerLeg", "LowerTorso", "RightUpperLeg"}

--// Frame

Library.UnloadCallback = Functions.Exit

local MainFrame = Library:CreateWindow({
	Name = "SIGMA YURI[v3.2]",
	Themeable = {
		Image = "348864556",
		Info = "universal GUI",
		Credit = false
	},
	Background = "348864556",
	Theme = [[{"__Designer.Colors.section":"107, 9, 19","__Designer.Colors.topGradient":"1B242F","__Designer.Settings.ShowHideKey":"Enum.KeyCode.RShift","__Designer.Colors.otherElementText":"54637D","__Designer.Colors.hoveredOptionBottom":"38667D","__Designer.Background.ImageAssetID":"348864556","__Designer.Colors.unhoveredOptionTop":"407495","__Designer.Colors.innerBorder":"2C4168","__Designer.Colors.unselectedOption":"4E6EA0","__Designer.Background.UseBackgroundImage":true,"__Designer.Files.WorkspaceFile":"Aimbot V2","__Designer.Colors.main":"23A0FF","__Designer.Colors.outerBorder":"162943","__Designer.Background.ImageColor":"FFFFFF","__Designer.Colors.tabText":"C9DFF1","__Designer.Colors.elementBorder":"111D26","__Designer.Colors.sectionBackground":"0E141C","__Designer.Colors.selectedOption":"558AC2","__Designer.Colors.background":"11182A","__Designer.Colors.bottomGradient":"202B42","__Designer.Background.ImageTransparency":0,"__Designer.Colors.hoveredOptionTop":"4885A0","__Designer.Colors.elementText":"7692B8","__Designer.Colors.unhoveredOptionBottom":"5471C4"}]]})

--// Tabs

local SettingsTab = MainFrame:CreateTab({
	Name = "A"
})

local FOVSettingsTab = MainFrame:CreateTab({
	Name = "F"
})

local FunctionsTab = MainFrame:CreateTab({
	Name = "_MOVEMENT_AIMBOT_"
})


local PvpTab = MainFrame:CreateTab({
	Name = "_ESP"
})



--// Settings - Sections

local Values = PvpTab:CreateSection({
	Name = "Visuals"
})


local Values = SettingsTab:CreateSection({
	Name = "Values"
})

local Checks = SettingsTab:CreateSection({
	Name = "Checks"
})

local ThirdPerson = SettingsTab:CreateSection({
	Name = "Third Person Mode?"
})

--// FOV Settings - Sections

local FOV_Values = FOVSettingsTab:CreateSection({
	Name = "Values"
})

local FOV_Appearance = FOVSettingsTab:CreateSection({
	Name = "Appearance"
})

--// Functions - Sections

local FunctionsSection = FunctionsTab:CreateSection({
	Name = "Functions"
})


local PvpSection = PvpTab:CreateSection({
	Name = "visual"
})
--// Settings / Values

Values:AddToggle({
	Name = "TURN ME OFF",
	Value = Settings.Enabled,
	Callback = function(New, Old)
		Settings.Enabled = New
	end
}).Default = Settings.Toggle

Values:AddToggle({
	Name = "Toggle",
	Value = Settings.Toggle,
	Callback = function(New, Old)
		Settings.Toggle = New
	end
}).Default = Settings.Toggle

Settings.LockPart = Parts[1]; Values:AddDropdown({
	Name = "Lock Part",
	Value = Parts[1],
	Callback = function(New, Old)
		Settings.LockPart = New
	end,
	List = Parts,
	Nothing = "Head"
}).Default = Parts[1]

Values:AddTextbox({ -- Using a Textbox instead of a Keybind because the UI Library doesn't support Mouse inputs like Left Click / Right Click...
	Name = "Hotkey",
	Value = Settings.TriggerKey,
	Callback = function(New, Old)
		Settings.TriggerKey = New
	end
}).Default = Settings.TriggerKey

--[[
Values:AddKeybind({
	Name = "Hotkey",
	Value = Settings.TriggerKey,
	Callback = function(New, Old)
		Settings.TriggerKey = stringmatch(tostring(New), "Enum%.[UserInputType]*[KeyCode]*%.(.+)")
	end,
}).Default = Settings.TriggerKey
]]




Values:AddSlider({
	Name = "Sensitivity",
	Value = Settings.Sensitivity,
	Callback = function(New, Old)
		Settings.Sensitivity = New
	end,
	Min = 0,
	Max = 1,
	Decimals = 2
}).Default = Settings.Sensitivity

--// Settings / Checks

Checks:AddToggle({
	Name = "Team Check",
	Value = Settings.TeamCheck,
	Callback = function(New, Old)
		Settings.TeamCheck = New
	end
}).Default = Settings.TeamCheck

Checks:AddToggle({
	Name = "Wall Check",
	Value = Settings.WallCheck,
	Callback = function(New, Old)
		Settings.WallCheck = New
	end
}).Default = Settings.WallCheck

Checks:AddToggle({
	Name = "Alive Check",
	Value = Settings.AliveCheck,
	Callback = function(New, Old)
		Settings.AliveCheck = New
	end
}).Default = Settings.AliveCheck

--// Settings / ThirdPerson

ThirdPerson:AddToggle({
	Name = "Enable Third Person",
	Value = Settings.ThirdPerson,
	Callback = function(New, Old)
		Settings.ThirdPerson = New
	end
}).Default = Settings.ThirdPerson

ThirdPerson:AddSlider({
	Name = "Sensitivity",
	Value = Settings.ThirdPersonSensitivity,
	Callback = function(New, Old)
		Settings.ThirdPersonSensitivity = New
	end,
	Min = 0.1,
	Max = 5,
	Decimals = 1
}).Default = Settings.ThirdPersonSensitivity

--// FOV Settings / Values



 
FOV_Values:AddToggle({
	Name = "Enabled",
	Value = FOVSettings.Enabled,
	Callback = function(New, Old)
		FOVSettings.Enabled = New
	end
}).Default = FOVSettings.Enabled

FOV_Values:AddToggle({
	Name = "Visible",
	Value = FOVSettings.Visible,
	Callback = function(New, Old)
		FOVSettings.Visible = New
	end
}).Default = FOVSettings.Visible

FOV_Values:AddSlider({
	Name = "Amount",
	Value = FOVSettings.Amount,
	Callback = function(New, Old)
		FOVSettings.Amount = New
	end,
	Min = 10,
	Max = 300
}).Default = FOVSettings.Amount

--// FOV Settings / Appearance

FOV_Appearance:AddToggle({
	Name = "Filled",
	Value = FOVSettings.Filled,
	Callback = function(New, Old)
		FOVSettings.Filled = New
	end
}).Default = FOVSettings.Filled

FOV_Appearance:AddSlider({
	Name = "Transparency",
	Value = FOVSettings.Transparency,
	Callback = function(New, Old)
		FOVSettings.Transparency = New
	end,
	Min = 0,
	Max = 1,
	Decimal = 1
}).Default = FOVSettings.Transparency

FOV_Appearance:AddSlider({
	Name = "Sides",
	Value = FOVSettings.Sides,
	Callback = function(New, Old)
		FOVSettings.Sides = New
	end,
	Min = 3,
	Max = 60
}).Default = FOVSettings.Sides

FOV_Appearance:AddSlider({
	Name = "Thickness",
	Value = FOVSettings.Thickness,
	Callback = function(New, Old)
		FOVSettings.Thickness = New
	end,
	Min = 1,
	Max = 50
}).Default = FOVSettings.Thickness

FOV_Appearance:AddColorpicker({
	Name = "Color",
	Value = FOVSettings.Color,
	Callback = function(New, Old)
		FOVSettings.Color = New
	end
}).Default = FOVSettings.Color

FOV_Appearance:AddColorpicker({
	Name = "Locked Color",
	Value = FOVSettings.LockedColor,
	Callback = function(New, Old)
		FOVSettings.LockedColor = New
	end
}).Default = FOVSettings.LockedColor









---------------------

FunctionsSection:AddButton({
	Name = "spam hitbox = fps drop",
	Callback = function()

	end
})

FunctionsSection:AddButton({
	Name = "hitbox reset[glitchy]",
	Callback = function()
_G.HeadSize = 1 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 10 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = true v.Character.Head.Massless = true end) end end end end)
	end
})



FunctionsSection:AddButton({
	Name = "hitbox extender [15]",
	Callback = function()
_G.HeadSize = 15 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})



FunctionsSection:AddButton({
	Name = "hitbox extender [20]",
	Callback = function()
_G.HeadSize = 20 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})


FunctionsSection:AddButton({
	Name = "HOOD CUSTOM legit",
	Callback = function()
_G.HeadSize = 1.3 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})

------
FunctionsSection:AddButton({
	Name = "HD{head[94%hit]}",
Callback = function()
_G.HeadSize = 2.4 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})	



FunctionsSection:AddButton({
	Name = "HD{blatant[100%]}",
Callback = function()
_G.HeadSize = 3 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})	

-----------------------------

FunctionsSection:AddButton({
	Name = "BYPASSED FLY V [cframe]",
Callback = function()
local Players = game:GetService("Players");
local UserInputService = game:GetService("UserInputService");
local RunService = game:GetService("RunService")

local Maid = loadstring(game:HttpGet('https://raw.githubusercontent.com/Quenty/NevermoreEngine/main/src/maid/src/Shared/Maid.lua'))()

shared.Maid = shared.Maid or Maid.new(); local Maid = shared.Maid; Maid:DoCleaning();
shared.Active = true;

local Ignore = false

local Offset = 1.34;

local Camera = workspace.CurrentCamera;

local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait();
local Character = LocalPlayer.Character or LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait();

local CurrentPoint = Character:GetPivot();

local task = table.clone(task);

local OldDelay = task.delay;

function task.delay(Time, Function)
    local Enabled = true;
    
    OldDelay(Time, function()
        if Enabled then
            Function();
        end
    end)
    
    return {
        Cancel = function()
            Enabled = false;
        end;
        Activate = function()
            Enabled = false
            Function()
        end
    }
end
local wait = task.wait;

local function StopVelocity()
    local HumanoidRootPart = Character and Character:FindFirstChild("HumanoidRootPart"); if not HumanoidRootPart then return end;
    
    HumanoidRootPart.Velocity = Vector3.zero;
end

Maid:GiveTask(LocalPlayer.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
end))

Maid:GiveTask(RunService.Stepped:Connect(function()
    if shared.Active then
        StopVelocity();
        local CameraCFrame = Camera.CFrame
        
        CurrentPoint = CFrame.new(CurrentPoint.Position, CurrentPoint.Position + CameraCFrame.LookVector)
        Character:PivotTo(CurrentPoint);
    end
end))

local CurrentTask = nil;

local KeyBindStarted = {
    [Enum.KeyCode.Q] = {
        ["FLY_UP"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.E) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, Offset, 0)
            end
        end;
    };
    [Enum.KeyCode.E] = {
        ["FLY_DOWN"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.Q) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, -Offset, 0)
            end
        end;
    };
    [Enum.KeyCode.W] = {
        ["FLY_FORWARD"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.W) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, 0, -Offset)
            end
        end;
    };
    [Enum.KeyCode.S] = {
        ["FLY_BACK"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.S) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, 0, Offset)
            end
        end;
    };
    [Enum.KeyCode.A] = {
        ["FLY_LEFT"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.A) do
                RunService.Stepped:Wait()
                if Ignore then continue end;

                CurrentPoint = CurrentPoint * CFrame.new(-Offset, 0, 0)
            end
        end;
    };
    [Enum.KeyCode.D] = {
        ["FLY_RIGHT"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.D) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(Offset, 0, 0)
            end
        end;
    };
    [Enum.KeyCode.Space] = {
        ["IGNORE_ON"] = function()
            Ignore = true
        end;
    };
    [Enum.KeyCode.V] = {
        ["TOGGLE"] = function()
            local Humanoid = Character:FindFirstChild("Humanoid") if not Humanoid then return end;
            local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart") if not HumanoidRootPart then return end;
            
            if not shared.Active then
                CurrentPoint = Character:GetPivot();
            else
                if CurrentTask then
                    CurrentTask:Activate()
                end
            
                StopVelocity();
                
                Character:PivotTo(CFrame.new(Character:GetPivot().Position))
                
                local RunServiceSignal = RunService.Stepped:Connect(function()
                    local AssemblyAngularVelocity = HumanoidRootPart.AssemblyAngularVelocity;
                    
                    if AssemblyAngularVelocity.X > 7 
                    or AssemblyAngularVelocity.Y > 7
                    or AssemblyAngularVelocity.Z > 7  then
                         Character:PivotTo(CFrame.new(Character:GetPivot().Position))
                    end
                end)
                
                CurrentTask = task.delay(10, function()
                    RunServiceSignal:Disconnect()
                end)
                
                Maid:GiveTask(RunServiceSignal)
            end
            
            shared.Active = not shared.Active
        end;
    }
}

local KeyBindEnded = {
    [Enum.KeyCode.Space] = {
        ["IGNORE_OFF"] = function()
            Ignore = false
        end;
    };
}

Maid:GiveTask(UserInputService.InputBegan:Connect(function(Input, GameProcessedEvent)
	if not GameProcessedEvent then
		if Input.UserInputType == Enum.UserInputType.Keyboard and KeyBindStarted[Input.KeyCode] then
			for _, Function in pairs(KeyBindStarted[Input.KeyCode]) do
				task.spawn(Function)
			end
		elseif KeyBindStarted[Input.UserInputType] then
			for _, Function in pairs(KeyBindStarted[Input.UserInputType]) do
                task.spawn(Function)
			end
		end
	end
end))

Maid:GiveTask(UserInputService.InputEnded:Connect(function(Input, GameProcessedEvent)
	if not GameProcessedEvent then
		if Input.UserInputType == Enum.UserInputType.Keyboard and KeyBindEnded[Input.KeyCode] then
			for _, Function in pairs(KeyBindEnded[Input.KeyCode]) do
				task.spawn(Function)
			end
		elseif KeyBindEnded[Input.UserInputType] then
			for _, Function in pairs(KeyBindEnded[Input.UserInputType]) do
                task.spawn(Function)
			end
		end
	end
end))



	end
})

FunctionsSection:AddButton({
	Name = "speedhack  Q [velocity]",
	Callback = function()
local speedhack = false

function onKeyPress(inputObject, gameProcessedEvent)
    if inputObject.KeyCode == Enum.KeyCode.Q and gameProcessedEvent == false then
     if speedhack == false then
       speedhack = true

     elseif speedhack == true then
       speedhack = false
    
       
     end
   end
end
 
game:GetService("UserInputService").InputBegan:connect(onKeyPress)


while wait() do
    if speedhack == true then
     game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.lookVector * 80
    end
    
end




	end
})
----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------



FunctionsSection:AddButton({
	Name = "HOODCUSTOMS LOCK[v1]",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.04
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})





--------------------------------------------------------

FunctionsSection:AddButton({
	Name = "AIMLOCK",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.02
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})








---------------












FunctionsSection:AddButton({
	Name = "1V1 HOOD",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = .115
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})






----





FunctionsSection:AddButton({
	Name = "DAHOOD",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = .1243
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})





FunctionsSection:AddButton({
	Name = "HOODCUSTOMS LOCK[v2]",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.06
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})

--This is the esp tab below btw

---------------------------------------------------------------------------------------------------

----



PvpSection:AddButton({
	Name = "player health",
	Callback = function()
--healthbar esp

local function ApplyESP(v)
   if v.Character and v.Character:FindFirstChildOfClass'Humanoid' then
       v.Character.Humanoid.NameDisplayDistance = 102
       v.Character.Humanoid.NameOcclusion = "NoOcclusion"
       v.Character.Humanoid.HealthDisplayDistance = 100
       v.Character.Humanoid.HealthDisplayType = "AlwaysOn"
       v.Character.Humanoid.Health = v.Character.Humanoid.Health -- triggers changed
   end
end
for i,v in pairs(game.Players:GetPlayers()) do
   ApplyESP(v)
   v.CharacterAdded:Connect(function()
       task.wait(0.33)
       ApplyESP(v)
   end)
end

game.Players.PlayerAdded:Connect(function(v)
   ApplyESP(v)
   v.CharacterAdded:Connect(function()
       task.wait(0.33)
       ApplyESP(v)
	   end)
	   end)

	end
})


---------------------------




PvpSection:AddButton({
	Name = "skeleton",
	Callback = function()
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Blissful4992/ESPs/main/UniversalSkeleton.lua"))()


local Skeletons = {}
for _, Player in next, game.Players:GetChildren() do
	table.insert(Skeletons, Library:NewSkeleton(Player, true));
end
game.Players.PlayerAdded:Connect(function(Player)
	table.insert(Skeletons, Library:NewSkeleton(Player, true));
end)

		end
})






------------------------------------------------

--
PvpSection:AddButton({
	Name = "RADAR",
	Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/Eazvy/UILibs/refs/heads/main/ESP/Arrows/Example"))()
		end
})





PvpSection:AddButton({
	Name = "rainbow torso[usebodychams]",
	Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/therangedpayeer/half-rainbow-body-client-sided/refs/heads/main/body%20chams"))()
		end
})


PvpSection:AddButton({
	Name = "red body",
	Callback = function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Function to make the character half-see-through and red
local function makeCharacterRedAndSeeThrough()
    -- Loop through all parts in the character and apply the effect
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            -- Make part half-see-through (transparency 0.5)
            part.Transparency = 0.9
            -- Change part color to red
            part.Color = Color3.fromRGB(255, 106, 84)
        end
    end
end

-- Call the function when the character is added
character:WaitForChild("HumanoidRootPart") -- Ensure the character is fully loaded before applying the changes
makeCharacterRedAndSeeThrough()

		end
})
