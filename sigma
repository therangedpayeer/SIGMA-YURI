

-- i have this open source so you can take anything from this cuz i did get the gui from exuny

--------------------------------------------------------------------------------------------------
 --may take some time to load also!


--change close keybind cuz its bugged



---
--18th /feb/ 25
--ADDED
--color changing avatar effect
--better hood customs presets
--esp gui
--hoping for more and better features soon!
--no longer adding or updating esp features 
--more presets for hood customs 
--fixed errors with new presets

--






 -- #####  #    # ### ######   #####     #     # #######  #####   #####     #     #####  ####### 
 --#     # #   #   #  #     # #     #    ##   ## #       #     # #     #   # #   #     # #       
 --#       #  #    #  #     # #          # # # # #       #       #        #   #  #       #       
 -- #####  ###     #  #     #  #####     #  #  # #####    #####   #####  #     # #  #### #####   
 --      # #  #    #  #     #       #    #     # #             #       # ####### #     # #       
 --#     # #   #   #  #     # #     #    #     # #       #     # #     # #     # #     # #       
 -- #####  #    # ### ######   #####     #     # #######  #####   #####  #     #  #####  ####### 
                                                                                               




--   YOU CAN STEAL ANYTHING HERE EVEN REPOST IT AND MAKE ALL OF IT YOURS IT DOES NOT MATTER TO ME



                                                                                                                                           












































































loadstring(game:HttpGet("https://raw.githubusercontent.com/therangedpayeer/client-sided-chat/refs/heads/main/dear%20sigma%20yuri%20user."))()





































































































































print("updates log loading...")
print("updates log loading..")
print("updates log loading.")
print("FOUND UPDATES!")
print("-----------------------------------------------------------------------")
print("IMPORTANT: free version discontinued soon...                          │")
print(" paid verison will be cheap costing 40 robux to keep sigma yuri going!│")
print("update logs                                                           │ ")
print("new esp features                                                      │")
print("added esp menu[small]                                                 │")
print("client sided body effects                                             │")
print("lock improvments                                                      │")
print("-----------------------------------------------------------------------")
print("game heavly supported 'combat warriors' 'da hood' 'hood customs'")
print("this cheat can be used on every game")
print("free version features move/aimbot tab has 16 working cheats esp tab has 10 working cheats+ rejoin and a game breaker!")



print("esp features are now discontinued!")































































-- Client-sided script

local player = game.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Create the GUI elements
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = playerGui

local messageLabel = Instance.new("TextLabel")
messageLabel.Parent = screenGui
messageLabel.Text = "[LOADING]welcome to sigmayuri[v3.5]"
messageLabel.TextSize = 30
messageLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
messageLabel.BackgroundTransparency = 0.5
messageLabel.Size = UDim2.new(0, 800, 0, 50)
messageLabel.Position = UDim2.new(0.5, -500, 0.5, -25) -- Centered on the screen
messageLabel.AnchorPoint = Vector2.new(0.5, 0.5)

-- Fade effect function
local function fadeOut()
    local fadeTime = 2 -- Time in seconds for the fade-out effect
    local startTime = tick()
    
    -- While the fade effect is in progress
    while tick() - startTime < fadeTime do
        local elapsedTime = tick() - startTime
        messageLabel.TextTransparency = elapsedTime / fadeTime
        wait(0.03) -- Wait for the next frame
    end
    
    -- After fade-out is complete, remove the message
    messageLabel:Destroy()
end

-- Show the message and then fade it out after 8 seconds
wait(5) -- Wait for 8 seconds before starting to fade
fadeOut()

----------

local loadstring, game, getgenv, setclipboard = loadstring, game, getgenv, setclipboard



if getgenv().Aimbot then return end


loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Aimbot-V2/main/Resources/Scripts/Raw%20Main.lua"))()



local Aimbot = getgenv().Aimbot
local Settings, FOVSettings, Functions = Aimbot.Settings, Aimbot.FOVSettings, Aimbot.Functions

local Library = loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)() -- Pepsi's UI Library

local Parts = {"Head", "HumanoidRootPart", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg", "UpperTorso", "LeftUpperLeg", "RightFoot", "RightLowerLeg", "LowerTorso", "RightUpperLeg"}

--// Frame

Library.UnloadCallback = Functions.Exit

local MainFrame = Library:CreateWindow({
	Name = "SIGMA YURI[v3.5]",
	Themeable = {
		Image = "348864556",
		Info = "hoodcustoms/dahood/universal",
		Credit = false
	},
	Background = "348864556",
	Theme = [[{"__Designer.Colors.section":"107, 9, 19","__Designer.Colors.topGradient":"1B242F","__Designer.Settings.ShowHideKey":"Enum.KeyCode.RShift","__Designer.Colors.otherElementText":"54637D","__Designer.Colors.hoveredOptionBottom":"38667D","__Designer.Background.ImageAssetID":"348864556","__Designer.Colors.unhoveredOptionTop":"407495","__Designer.Colors.innerBorder":"2C4168","__Designer.Colors.unselectedOption":"4E6EA0","__Designer.Background.UseBackgroundImage":true,"__Designer.Files.WorkspaceFile":"Aimbot V2","__Designer.Colors.main":"23A0FF","__Designer.Colors.outerBorder":"162943","__Designer.Background.ImageColor":"FFFFFF","__Designer.Colors.tabText":"C9DFF1","__Designer.Colors.elementBorder":"111D26","__Designer.Colors.sectionBackground":"0E141C","__Designer.Colors.selectedOption":"558AC2","__Designer.Colors.background":"11182A","__Designer.Colors.bottomGradient":"202B42","__Designer.Background.ImageTransparency":0,"__Designer.Colors.hoveredOptionTop":"4885A0","__Designer.Colors.elementText":"7692B8","__Designer.Colors.unhoveredOptionBottom":"5471C4"}]]})

--// Tabs

local SettingsTab = MainFrame:CreateTab({
	Name = "A"
})

local FOVSettingsTab = MainFrame:CreateTab({
	Name = "F"
})

local FunctionsTab = MainFrame:CreateTab({
	Name = "_MOVEMENT_AIMBOT_"
})


local PvpTab = MainFrame:CreateTab({
	Name = "_ESP"
})



--// Settings - Sections

local Values = PvpTab:CreateSection({
	Name = "Visuals"
})


local Values = SettingsTab:CreateSection({
	Name = "Values"
})

local Checks = SettingsTab:CreateSection({
	Name = "Checks"
})

local ThirdPerson = SettingsTab:CreateSection({
	Name = "Third Person Mode?"
})

--// FOV Settings - Sections

local FOV_Values = FOVSettingsTab:CreateSection({
	Name = "Values"
})

local FOV_Appearance = FOVSettingsTab:CreateSection({
	Name = "Appearance"
})

--// Functions - Sections

local FunctionsSection = FunctionsTab:CreateSection({
	Name = "Functions"
})


local PvpSection = PvpTab:CreateSection({
	Name = "visual"
})
--// Settings / Values

Values:AddToggle({
	Name = "TURN ME OFF",
	Value = Settings.Enabled,
	Callback = function(New, Old)
		Settings.Enabled = New
	end
}).Default = Settings.Toggle

Values:AddToggle({
	Name = "Toggle",
	Value = Settings.Toggle,
	Callback = function(New, Old)
		Settings.Toggle = New
	end
}).Default = Settings.Toggle

Settings.LockPart = Parts[1]; Values:AddDropdown({
	Name = "Lock Part",
	Value = Parts[1],
	Callback = function(New, Old)
		Settings.LockPart = New
	end,
	List = Parts,
	Nothing = "Head"
}).Default = Parts[1]

Values:AddTextbox({ -- Using a Textbox instead of a Keybind because the UI Library doesn't support Mouse inputs like Left Click / Right Click...
	Name = "Hotkey",
	Value = Settings.TriggerKey,
	Callback = function(New, Old)
		Settings.TriggerKey = New
	end
}).Default = Settings.TriggerKey

--[[
Values:AddKeybind({
	Name = "Hotkey",
	Value = Settings.TriggerKey,
	Callback = function(New, Old)
		Settings.TriggerKey = stringmatch(tostring(New), "Enum%.[UserInputType]*[KeyCode]*%.(.+)")
	end,
}).Default = Settings.TriggerKey
]]




Values:AddSlider({
	Name = "Sensitivity",
	Value = Settings.Sensitivity,
	Callback = function(New, Old)
		Settings.Sensitivity = New
	end,
	Min = 0,
	Max = 1,
	Decimals = 2
}).Default = Settings.Sensitivity

--// Settings / Checks

Checks:AddToggle({
	Name = "Team Check",
	Value = Settings.TeamCheck,
	Callback = function(New, Old)
		Settings.TeamCheck = New
	end
}).Default = Settings.TeamCheck

Checks:AddToggle({
	Name = "Wall Check",
	Value = Settings.WallCheck,
	Callback = function(New, Old)
		Settings.WallCheck = New
	end
}).Default = Settings.WallCheck

Checks:AddToggle({
	Name = "Alive Check",
	Value = Settings.AliveCheck,
	Callback = function(New, Old)
		Settings.AliveCheck = New
	end
}).Default = Settings.AliveCheck

--// Settings / ThirdPerson

ThirdPerson:AddToggle({
	Name = "Enable Third Person",
	Value = Settings.ThirdPerson,
	Callback = function(New, Old)
		Settings.ThirdPerson = New
	end
}).Default = Settings.ThirdPerson

ThirdPerson:AddSlider({
	Name = "Sensitivity",
	Value = Settings.ThirdPersonSensitivity,
	Callback = function(New, Old)
		Settings.ThirdPersonSensitivity = New
	end,
	Min = 0.1,
	Max = 5,
	Decimals = 1
}).Default = Settings.ThirdPersonSensitivity

--// FOV Settings / Values



 
FOV_Values:AddToggle({
	Name = "Enabled",
	Value = FOVSettings.Enabled,
	Callback = function(New, Old)
		FOVSettings.Enabled = New
	end
}).Default = FOVSettings.Enabled

FOV_Values:AddToggle({
	Name = "Visible",
	Value = FOVSettings.Visible,
	Callback = function(New, Old)
		FOVSettings.Visible = New
	end
}).Default = FOVSettings.Visible

FOV_Values:AddSlider({
	Name = "Amount",
	Value = FOVSettings.Amount,
	Callback = function(New, Old)
		FOVSettings.Amount = New
	end,
	Min = 10,
	Max = 300
}).Default = FOVSettings.Amount

--// FOV Settings / Appearance

FOV_Appearance:AddToggle({
	Name = "Filled",
	Value = FOVSettings.Filled,
	Callback = function(New, Old)
		FOVSettings.Filled = New
	end
}).Default = FOVSettings.Filled

FOV_Appearance:AddSlider({
	Name = "Transparency",
	Value = FOVSettings.Transparency,
	Callback = function(New, Old)
		FOVSettings.Transparency = New
	end,
	Min = 0,
	Max = 1,
	Decimal = 1
}).Default = FOVSettings.Transparency

FOV_Appearance:AddSlider({
	Name = "Sides",
	Value = FOVSettings.Sides,
	Callback = function(New, Old)
		FOVSettings.Sides = New
	end,
	Min = 3,
	Max = 60
}).Default = FOVSettings.Sides

FOV_Appearance:AddSlider({
	Name = "Thickness",
	Value = FOVSettings.Thickness,
	Callback = function(New, Old)
		FOVSettings.Thickness = New
	end,
	Min = 1,
	Max = 50
}).Default = FOVSettings.Thickness

FOV_Appearance:AddColorpicker({
	Name = "Color",
	Value = FOVSettings.Color,
	Callback = function(New, Old)
		FOVSettings.Color = New
	end
}).Default = FOVSettings.Color

FOV_Appearance:AddColorpicker({
	Name = "Locked Color",
	Value = FOVSettings.LockedColor,
	Callback = function(New, Old)
		FOVSettings.LockedColor = New
	end
}).Default = FOVSettings.LockedColor









---------------------

FunctionsSection:AddButton({
	Name = "spam hitbox = fps drop[TIP]",
	Callback = function()

	end
})

FunctionsSection:AddButton({
	Name = "hitbox reset[glitched]",
	Callback = function()
_G.HeadSize = 1 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 10 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = true v.Character.Head.Massless = true end) end end end end)
	end
})



FunctionsSection:AddButton({
	Name = "hitbox extender [15]",
	Callback = function()
_G.HeadSize = 15 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})



FunctionsSection:AddButton({
	Name = "hitbox extender [20]",
	Callback = function()
_G.HeadSize = 20 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})


FunctionsSection:AddButton({
	Name = "HOOD CUSTOM legit",
	Callback = function()
_G.HeadSize = 1.3 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})



FunctionsSection:AddButton({
	Name = "hoodcustosm[v2]",
	Callback = function()
_G.HeadSize = 1.8 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 10 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = true v.Character.Head.Massless = true end) end end end end)
	end
})



---
------
FunctionsSection:AddButton({
	Name = "HD{head[94%hit]}",
Callback = function()
_G.HeadSize = 2.4 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})	

FunctionsSection:AddButton({
	Name = "HD{TORSO}100%",
Callback = function()
_G.TorsoSize = 2.5 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Torso.Size = Vector3.new(_G.TorsoSize,_G.TorsoSize,_G.TorsoSize) v.Character.Torso.Transparency = 0.1 v.Character.Torso.BrickColor = BrickColor.new("Red") v.Character.Torso.Material = "Neon" v.Character.Torso.CanCollide = false v.Character.Torso.Massless = true end) end end end end)
	end
})	

FunctionsSection:AddButton({
	Name = "HD{blatant[100%]}",
Callback = function()
_G.HeadSize = 3 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})	

-----------------------------

FunctionsSection:AddButton({
	Name = "BYPASSED FLY V [cframe]",
Callback = function()
local Players = game:GetService("Players");
local UserInputService = game:GetService("UserInputService");
local RunService = game:GetService("RunService")

local Maid = loadstring(game:HttpGet('https://raw.githubusercontent.com/Quenty/NevermoreEngine/main/src/maid/src/Shared/Maid.lua'))()

shared.Maid = shared.Maid or Maid.new(); local Maid = shared.Maid; Maid:DoCleaning();
shared.Active = true;

local Ignore = false

local Offset = 1.34;

local Camera = workspace.CurrentCamera;

local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait();
local Character = LocalPlayer.Character or LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait();

local CurrentPoint = Character:GetPivot();

local task = table.clone(task);

local OldDelay = task.delay;

function task.delay(Time, Function)
    local Enabled = true;
    
    OldDelay(Time, function()
        if Enabled then
            Function();
        end
    end)
    
    return {
        Cancel = function()
            Enabled = false;
        end;
        Activate = function()
            Enabled = false
            Function()
        end
    }
end
local wait = task.wait;

local function StopVelocity()
    local HumanoidRootPart = Character and Character:FindFirstChild("HumanoidRootPart"); if not HumanoidRootPart then return end;
    
    HumanoidRootPart.Velocity = Vector3.zero;
end

Maid:GiveTask(LocalPlayer.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
end))

Maid:GiveTask(RunService.Stepped:Connect(function()
    if shared.Active then
        StopVelocity();
        local CameraCFrame = Camera.CFrame
        
        CurrentPoint = CFrame.new(CurrentPoint.Position, CurrentPoint.Position + CameraCFrame.LookVector)
        Character:PivotTo(CurrentPoint);
    end
end))

local CurrentTask = nil;

local KeyBindStarted = {
    [Enum.KeyCode.Q] = {
        ["FLY_UP"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.E) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, Offset, 0)
            end
        end;
    };
    [Enum.KeyCode.E] = {
        ["FLY_DOWN"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.Q) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, -Offset, 0)
            end
        end;
    };
    [Enum.KeyCode.W] = {
        ["FLY_FORWARD"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.W) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, 0, -Offset)
            end
        end;
    };
    [Enum.KeyCode.S] = {
        ["FLY_BACK"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.S) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, 0, Offset)
            end
        end;
    };
    [Enum.KeyCode.A] = {
        ["FLY_LEFT"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.A) do
                RunService.Stepped:Wait()
                if Ignore then continue end;

                CurrentPoint = CurrentPoint * CFrame.new(-Offset, 0, 0)
            end
        end;
    };
    [Enum.KeyCode.D] = {
        ["FLY_RIGHT"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.D) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(Offset, 0, 0)
            end
        end;
    };
    [Enum.KeyCode.Space] = {
        ["IGNORE_ON"] = function()
            Ignore = true
        end;
    };
    [Enum.KeyCode.V] = {
        ["TOGGLE"] = function()
            local Humanoid = Character:FindFirstChild("Humanoid") if not Humanoid then return end;
            local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart") if not HumanoidRootPart then return end;
            
            if not shared.Active then
                CurrentPoint = Character:GetPivot();
            else
                if CurrentTask then
                    CurrentTask:Activate()
                end
            
                StopVelocity();
                
                Character:PivotTo(CFrame.new(Character:GetPivot().Position))
                
                local RunServiceSignal = RunService.Stepped:Connect(function()
                    local AssemblyAngularVelocity = HumanoidRootPart.AssemblyAngularVelocity;
                    
                    if AssemblyAngularVelocity.X > 7 
                    or AssemblyAngularVelocity.Y > 7
                    or AssemblyAngularVelocity.Z > 7  then
                         Character:PivotTo(CFrame.new(Character:GetPivot().Position))
                    end
                end)
                
                CurrentTask = task.delay(10, function()
                    RunServiceSignal:Disconnect()
                end)
                
                Maid:GiveTask(RunServiceSignal)
            end
            
            shared.Active = not shared.Active
        end;
    }
}

local KeyBindEnded = {
    [Enum.KeyCode.Space] = {
        ["IGNORE_OFF"] = function()
            Ignore = false
        end;
    };
}

Maid:GiveTask(UserInputService.InputBegan:Connect(function(Input, GameProcessedEvent)
	if not GameProcessedEvent then
		if Input.UserInputType == Enum.UserInputType.Keyboard and KeyBindStarted[Input.KeyCode] then
			for _, Function in pairs(KeyBindStarted[Input.KeyCode]) do
				task.spawn(Function)
			end
		elseif KeyBindStarted[Input.UserInputType] then
			for _, Function in pairs(KeyBindStarted[Input.UserInputType]) do
                task.spawn(Function)
			end
		end
	end
end))

Maid:GiveTask(UserInputService.InputEnded:Connect(function(Input, GameProcessedEvent)
	if not GameProcessedEvent then
		if Input.UserInputType == Enum.UserInputType.Keyboard and KeyBindEnded[Input.KeyCode] then
			for _, Function in pairs(KeyBindEnded[Input.KeyCode]) do
				task.spawn(Function)
			end
		elseif KeyBindEnded[Input.UserInputType] then
			for _, Function in pairs(KeyBindEnded[Input.UserInputType]) do
                task.spawn(Function)
			end
		end
	end
end))



	end
})

FunctionsSection:AddButton({
	Name = "speedhack  Q [velocity]",
	Callback = function()
local speedhack = false

function onKeyPress(inputObject, gameProcessedEvent)
    if inputObject.KeyCode == Enum.KeyCode.Q and gameProcessedEvent == false then
     if speedhack == false then
       speedhack = true

     elseif speedhack == true then
       speedhack = false
    
       
     end
   end
end
 
game:GetService("UserInputService").InputBegan:connect(onKeyPress)


while wait() do
    if speedhack == true then
     game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.lookVector * 80
    end
    
end




	end
})
----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------



FunctionsSection:AddButton({
	Name = "HOODCUSTOMSLOCK[v1][torso]",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.04
getgenv().AimPart = "LowerTorso"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Sqaure")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})



FunctionsSection:AddButton({
	Name = "HOODCUSTOMSLOCK[v2][torso]",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.05
getgenv().AimPart = "UpperTorso"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})








































--------------------------------------------------------

FunctionsSection:AddButton({
	Name = "AIMLOCK",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.02
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})








---------------












FunctionsSection:AddButton({
	Name = "1V1 HOOD",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = .115
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})






----





FunctionsSection:AddButton({
	Name = "DAHOOD",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = .1243
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})





FunctionsSection:AddButton({
	Name = "HOODCUSTOMS LOCK[v2]",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.06
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})

--This is the esp tab below btw

---------------------------------------------------------------------------------------------------

----



PvpSection:AddButton({
	Name = "player health",
	Callback = function()
--healthbar esp

local function ApplyESP(v)
   if v.Character and v.Character:FindFirstChildOfClass'Humanoid' then
       v.Character.Humanoid.NameDisplayDistance = 102
       v.Character.Humanoid.NameOcclusion = "NoOcclusion"
       v.Character.Humanoid.HealthDisplayDistance = 100
       v.Character.Humanoid.HealthDisplayType = "AlwaysOn"
       v.Character.Humanoid.Health = v.Character.Humanoid.Health -- triggers changed
   end
end
for i,v in pairs(game.Players:GetPlayers()) do
   ApplyESP(v)
   v.CharacterAdded:Connect(function()
       task.wait(0.33)
       ApplyESP(v)
   end)
end

game.Players.PlayerAdded:Connect(function(v)
   ApplyESP(v)
   v.CharacterAdded:Connect(function()
       task.wait(0.33)
       ApplyESP(v)
	   end)
	   end)

	end
})


---------------------------




PvpSection:AddButton({
	Name = "skeleton",
	Callback = function()
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Blissful4992/ESPs/main/UniversalSkeleton.lua"))()


local Skeletons = {}
for _, Player in next, game.Players:GetChildren() do
	table.insert(Skeletons, Library:NewSkeleton(Player, true));
end
game.Players.PlayerAdded:Connect(function(Player)
	table.insert(Skeletons, Library:NewSkeleton(Player, true));
end)

		end
})






------------------------------------------------

--
PvpSection:AddButton({
	Name = "RADAR",
	Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/Eazvy/UILibs/refs/heads/main/ESP/Arrows/Example"))()
		end
})





PvpSection:AddButton({
	Name = "rainbow torso[usebodychams]",
	Callback = function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/therangedpayeer/half-rainbow-body-client-sided/refs/heads/main/body%20chams"))()
		end
})


PvpSection:AddButton({
	Name = "red body[clear]",
	Callback = function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Function to make the character half-see-through and red
local function makeCharacterRedAndSeeThrough()
    -- Loop through all parts in the character and apply the effect
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            -- Make part half-see-through (transparency 0.5)
            part.Transparency = 0.7
            -- Change part color to red
            part.Color = Color3.fromRGB(255, 0, 0)
        end
    end
end

-- Call the function when the character is added
character:WaitForChild("HumanoidRootPart") -- Ensure the character is fully loaded before applying the changes
makeCharacterRedAndSeeThrough()

		end
})






PvpSection:AddButton({
	Name = "WHITE[clearish]",
	Callback = function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Function to make the character half-see-through and red
local function makeCharacterRedAndSeeThrough()
    -- Loop through all parts in the character and apply the effect
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            -- Make part half-see-through (transparency 0.5)
            part.Transparency = 0.6
            -- Change part color to red
            part.Color = Color3.fromRGB(255, 255, 255)
        end
    end
end

-- Call the function when the character is added
character:WaitForChild("HumanoidRootPart") -- Ensure the character is fully loaded before applying the changes
makeCharacterRedAndSeeThrough()

		end
})




















-----------------------------------------










PvpSection:AddButton({
	Name = "watermelonREDISH[clear]",
	Callback = function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Function to make the character half-see-through and red
local function makeCharacterRedAndSeeThrough()
    -- Loop through all parts in the character and apply the effect
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            -- Make part half-see-through (transparency 0.5)
            part.Transparency = 0.6
            -- Change part color to red
            part.Color = Color3.fromRGB(253, 70, 89)
        end
    end
end

-- Call the function when the character is added
character:WaitForChild("HumanoidRootPart") -- Ensure the character is fully loaded before applying the changes
makeCharacterRedAndSeeThrough()

		end
})
----------------------------



PvpSection:AddButton({
	Name = "rainbow{clear}",
	Callback = function()
-- LocalScript inside StarterPlayer -> StarterPlayerScripts

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Function to apply neon material and make head invisible
local function applyNeonEffect()
    -- Wait for the character to fully load
    character:WaitForChild("Head")

    -- Make the head invisible
    local head = character:FindFirstChild("Head")
    if head then
        head.Transparency = 1 -- Fully invisible head
        head.CanCollide = false -- Disable collision for the head
    end

    -- Apply neon material and color-changing effect to body parts
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "Head" then
            part.Material = Enum.Material.ForceField
        end
    end
end

-- Function to continuously change the colors of body parts
local function changeBodyColors()
    while true do
        local time = tick()  -- Get current time
        local colorValue = math.sin(time) / 2 + 0.5 -- Smooth color oscillation

        -- Calculate a new color based on the oscillation value
        local color = Color3.fromHSV(colorValue, 1, 1)  -- Change color over time (Rainbow effect)

        -- Apply the color to each part (except head)
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") and part.Name ~= "Head" then
                part.Color = color
            end
        end

        wait(0.0000000000000000000000000000005)  -- Wait for a short time before the next color update
    end
end

-- Apply effects when the character is loaded or respawns
character:WaitForChild("HumanoidRootPart")
applyNeonEffect()

-- Start color-changing loop
spawn(changeBodyColors)

-- Apply the effects when the character respawns
player.CharacterAdded:Connect(function(char)
    character = char
    character:WaitForChild("HumanoidRootPart")
    applyNeonEffect()
    spawn(changeBodyColors)  -- Start the color-changing effect again after respawn
end)

end
})











PvpSection:AddButton({
	Name = "color flashing{WHITE}",
	Callback = function()
-- Place this script in a LocalScript (for client-side execution)
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Function to make the character neon and invisible
local function toggleNeonInvisibility()
    while true do
        -- Make all parts bright neon
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Material = Enum.Material.Neon
                part.Color = Color3.fromRGB(255, 255, 255)  -- Change color to bright red
            end
        end
        
        -- Wait a little bit before making the character invisible
        wait(0.3)
        
        -- Make all parts invisible
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 1  -- Full transparency (invisible)
            end
        end
        
        -- Wait a little bit before showing the character again
        wait(0)
        
        -- Make the character visible again
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Transparency = 0  -- Full opacity (visible)
            end
        end
    end
end

-- Start the neon invisibility loop
toggleNeonInvisibility()

end
})

PvpSection:AddButton({
	Name = "esp menu[small]",
	Callback = function()

-- Gui to Lua


-- Instances:

local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local Update = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")
local Color2 = Instance.new("TextButton")
local Color1 = Instance.new("TextButton")
local Close = Instance.new("TextButton")
local Open = Instance.new("TextButton")

--Properties:

ScreenGui.Parent = game.CoreGui
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling


Frame.Parent = ScreenGui
Frame.Active = true
Frame.Draggable = true
Frame.BackgroundColor3 = Color3.fromRGB(89, 89, 89)
Frame.Position = UDim2.new(0.746872663, 0, 0.697815537, 0)
Frame.Size = UDim2.new(0, 292, 0, 214)

Update.Name = "FIX esp?"
Update.Parent = Frame
Update.BackgroundColor3 = Color3.fromRGB(129, 2, 255)
Update.Position = UDim2.new(0.157534242, 0, 0.696261644, 0)
Update.Size = UDim2.new(0, 200, 0, 50)
Update.Font = Enum.Font.Michroma
Update.Text = "Update Esp"
Update.TextColor3 = Color3.fromRGB(0, 0, 0)
Update.TextSize = 14.000

UICorner.Parent = Frame

Color2.Name = "Color2"
Color2.Parent = Frame
Color2.BackgroundColor3 = Color3.fromRGB(255, 226, 8)
Color2.Position = UDim2.new(0.595890403, 0, 0.355140179, 0)
Color2.Size = UDim2.new(0, 72, 0, 50)
Color2.Font = Enum.Font.SourceSans
Color2.Text = "WHITE"
Color2.TextColor3 = Color3.fromRGB(0, 0, 0)
Color2.TextScaled = true
Color2.TextSize = 14.000
Color2.TextWrapped = true

Color1.Name = "Color1"
Color1.Parent = Frame
Color1.BackgroundColor3 = Color3.fromRGB(255, 0, 4)
Color1.Position = UDim2.new(0.157534242, 0, 0.355140179, 0)
Color1.Size = UDim2.new(0, 72, 0, 50)
Color1.Font = Enum.Font.SourceSans
Color1.Text = "RED"
Color1.TextColor3 = Color3.fromRGB(0, 0, 0)
Color1.TextScaled = true
Color1.TextSize = 14.000
Color1.TextWrapped = true

Close.Name = "Close"
Close.Parent = Frame
Close.BackgroundColor3 = Color3.fromRGB(255, 41, 87)
Close.Position = UDim2.new(0.157534242, 0, 0, 0)
Close.Size = UDim2.new(0, 200, 0, 33)
Close.Font = Enum.Font.Michroma
Close.Text = "SIGMAYURI[v3.5]"
Close.TextColor3 = Color3.fromRGB(0, 0, 0)
Close.TextScaled = true
Close.TextSize = 14.000
Close.TextWrapped = true

Open.Name = "Open"
Open.Parent = ScreenGui
Open.BackgroundColor3 = Color3.fromRGB(25, 0, 10)
Open.Position = UDim2.new(0.470198661, 640, 0.737864077, -40)
Open.Size = UDim2.new(0, 81, 0, 26)
Open.Visible = false
Open.Font = Enum.Font.SourceSans
Open.Text = "Open"
Open.TextColor3 = Color3.fromRGB(255, 255, 255)
Open.TextScaled = true
Open.TextSize = 14.000
Open.TextWrapped = true

-- Scripts:

local function XFNH_fake_script() -- Close.LocalScript 
    local script = Instance.new('LocalScript', Close)

    local frame = Frame
    
    local open = ScreenGui.Open
    
    script.Parent.MouseButton1Up:Connect(function()
        open.Visible = true
        frame.Visible = false
    end)
    
end
coroutine.wrap(XFNH_fake_script)()
local function LCEJPX_fake_script() -- Frame.ESPmain 
    local script = Instance.new('LocalScript', Frame)

    
    local players = game.Players:GetPlayers()
    
    local c1 = script.Parent.Color1
    local c2 = script.Parent.Color2
    
    local update = script.Parent.Update
    
    local boxcolor = 1
    
    update.MouseButton1Up:Connect(function()
        local players = game.Players:GetPlayers()
        for i,v in pairs(players) do
            if v ~= game.Players.LocalPlayer then
                if boxcolor == 1 then
                   local BoxEsp = Instance.new("HighLight")
                    BoxEsp.Name = v.Name
                    BoxEsp.FillTransparency = 0.5
                    BoxEsp.FillColor = Color3.new(255,255,255)
                    BoxEsp.OutlineColor = Color3.new(255, 255, 255)
                    BoxEsp.OutlineTransparency = 0
                    BoxEsp.Parent = v.Character
                elseif boxcolor == 2 then
                    local BoxEsp = Instance.new("HighLight")
                    BoxEsp.Name = v.Name
                    BoxEsp.FillTransparency = 0.9
                    BoxEsp.FillColor = Color3.new(255,255,0)
                    BoxEsp.OutlineColor = Color3.new(255, 255, 255)
                    BoxEsp.OutlineTransparency = 0
                    BoxEsp.Parent = v.Character
                end
            elseif v == game.Players.LocalPlayer then
                local BoxEsp = Instance.new("Highlight")
                BoxEsp.Name = v.Name
                BoxEsp.FillTransparency = 0.7
                BoxEsp.FillColor = Color3.new(0, 100, 200)
                BoxEsp.OutlineColor = Color3.new(255, 255, 255)
                BoxEsp.OutlineTransparency = 1
                BoxEsp.Parent = v.Character
            end
        end
        
    end)
    
    
    
    
    
    
    c1.MouseButton1Up:Connect(function()
        boxcolor = 1
    end)
    
    c2.MouseButton1Up:Connect(function()
        boxcolor = 2
    end)
end
coroutine.wrap(LCEJPX_fake_script)()
local function LCAO_fake_script() -- Open.LocalScript 
    local script = Instance.new('LocalScript', Open)

    local frame = Frame
    
    local open = ScreenGui.Open
    
    
    
    script.Parent.MouseButton1Up:Connect(function()
        open.Visible = false
        frame.Visible = true
    end)
    
    
    
end
coroutine.wrap(LCAO_fake_script)()
end
})



----------------------------

PvpSection:AddButton({
	Name = "----player-section----",
	Callback = function()

end
})




PvpSection:AddButton({
	Name = "GAME BREAKER!!",
	Callback = function()
-- Place this script in a LocalScript (for client-side execution)
local player = game.Players.LocalPlayer
local soundService = game:GetService("SoundService")

-- Create the sound object
local screamSound = Instance.new("Sound")
screamSound.SoundId = "rbxassetid://892233254"


  -- Replace with your scream sound ID
screamSound.Parent = player.Character or player.CharacterAdded:Wait()  -- Attach sound to character (or workspace if preferred)

-- Set properties of the sound
screamSound.Volume = 10.4  -- Adjust volume (0 to 1)
screamSound.Looped = true  -- Make the sound loop
screamSound.Playing = true  -- Start playing the sound immediately

-- Play the sound continuously
screamSound:Play()

-- Optional: Make sure it keeps playing after respawn
player.CharacterAdded:Connect(function(character)
    screamSound.Parent = character  -- Reattach to new character
    screamSound:Play()
end)
---------------------------------------------

-- Place this script in a LocalScript (for client-side execution)
local player = game.Players.LocalPlayer
local screenGui = Instance.new("ScreenGui")
local tweenService = game:GetService("TweenService")

-- Set up the ScreenGui
screenGui.Name = "MessageGui"
screenGui.Parent = player.PlayerGui
screenGui.ResetOnSpawn = false  -- Prevent it from resetting when the player respawns

-- Function to create a bouncing message
local function createBouncingMessage()
    -- Create a new TextLabel for the message
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "MessageLabel"
    textLabel.Parent = screenGui
    textLabel.Text = "Congrats, your game is destroyed!"  -- Message
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.TextSize = 100
    textLabel.TextColor3 = Color3.fromRGB(255, 0, 0)  -- Red text
    textLabel.BackgroundTransparency = 1  -- Transparent background
    textLabel.Size = UDim2.new(0, 300, 0, 50)  -- Size of the message box
    textLabel.Position = UDim2.new(math.random(), 0, math.random(), 0)  -- Random position on the screen

    -- Randomize bounce movement speed
    local bounceSpeed = math.random(5, 10)  -- Random bounce speed

    -- Create tweening for bouncing animation
    local tweenInfo = TweenInfo.new(bounceSpeed, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out, -1, true)  -- Bounce back and forth
    local goal = {Position = UDim2.new(math.random(), 0, math.random(), 0)}  -- Move the text to a new random position

    -- Create the bouncing tween
    local bounceTween = tweenService:Create(textLabel, tweenInfo, goal)
    bounceTween:Play()

    -- Function to create multiple text labels (multiply effect)
    local function multiplyMessages()
        wait(1)  -- Wait a second before multiplying
        for i = 1, 2 do  -- Create two more labels for each message
            local newMessage = createBouncingMessage()  -- Create a new message that multiplies
            newMessage.Position = UDim2.new(math.random(), 0, math.random(), 0)  -- Random initial position
        end
    end

    -- Call multiply after a short delay
    spawn(multiplyMessages)
end

-- Start the first bouncing message
createBouncingMessage()

---------------------------------------------
-- Place this script inside a LocalScript (for client-side execution)
local player = game.Players.LocalPlayer
local camera = game.Workspace.CurrentCamera
local runService = game:GetService("RunService")

-- This variable controls the speed of the spinning
local spinSpeed = 350  -- Adjust this value to control the spin speed

-- Function to make the camera spin
local function spinCamera()
    while true do
        -- Spin the camera by rotating it around the Y-axis
        local newCFrame = camera.CFrame * CFrame.Angles(-35, math.rad(spinSpeed), 45)
        camera.CFrame = newCFrame
        wait(0.1)  -- Adjust the wait time for smoother or choppier spins
    end
end

-- Ensure the player is in first person before starting the spin
player.CameraMode = Enum.CameraMode.LockFirstPerson

-- Start the spinning effect
spinCamera()



end
})




------------------------------


PvpSection:AddButton({
	Name = "rejoin?",
	Callback = function()
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
 
local Rejoin = coroutine.create(function()
    local Success, ErrorMessage = pcall(function()
        TeleportService:Teleport(game.PlaceId, LocalPlayer)
    end)
 
    if ErrorMessage and not Success then
        warn(ErrorMessage)
    end
end)
 
coroutine.resume(Rejoin)

end
})
