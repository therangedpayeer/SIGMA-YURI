

-- i have this open source so you can take anything from this cuz i did get the gui from exuny

--------------------------------------------------------------------------------------------------
 --may take some time to load also!


--change close keybind cuz its bugged































local loadstring, game, getgenv, setclipboard = loadstring, game, getgenv, setclipboard



if getgenv().Aimbot then return end


loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Aimbot-V2/main/Resources/Scripts/Raw%20Main.lua"))()



local Aimbot = getgenv().Aimbot
local Settings, FOVSettings, Functions = Aimbot.Settings, Aimbot.FOVSettings, Aimbot.Functions

local Library = loadstring(game:GetObjects("rbxassetid://7657867786")[1].Source)() -- Pepsi's UI Library

local Parts = {"Head", "HumanoidRootPart", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "LeftHand", "RightHand", "LeftLowerArm", "RightLowerArm", "LeftUpperArm", "RightUpperArm", "LeftFoot", "LeftLowerLeg", "UpperTorso", "LeftUpperLeg", "RightFoot", "RightLowerLeg", "LowerTorso", "RightUpperLeg"}

--// Frame

Library.UnloadCallback = Functions.Exit

local MainFrame = Library:CreateWindow({
	Name = "SIGMA YURI[v3.1]",
	Themeable = {
		Image = "348864556",
		Info = "universal GUI",
		Credit = false
	},
	Background = "348864556",
	Theme = [[{"__Designer.Colors.section":"255, 9, 179","__Designer.Colors.topGradient":"1B242F","__Designer.Settings.ShowHideKey":"Enum.KeyCode.RShift","__Designer.Colors.otherElementText":"54637D","__Designer.Colors.hoveredOptionBottom":"38667D","__Designer.Background.ImageAssetID":"348864556","__Designer.Colors.unhoveredOptionTop":"407495","__Designer.Colors.innerBorder":"2C4168","__Designer.Colors.unselectedOption":"4E6EA0","__Designer.Background.UseBackgroundImage":true,"__Designer.Files.WorkspaceFile":"Aimbot V2","__Designer.Colors.main":"23A0FF","__Designer.Colors.outerBorder":"162943","__Designer.Background.ImageColor":"FFFFFF","__Designer.Colors.tabText":"C9DFF1","__Designer.Colors.elementBorder":"111D26","__Designer.Colors.sectionBackground":"0E141C","__Designer.Colors.selectedOption":"558AC2","__Designer.Colors.background":"11182A","__Designer.Colors.bottomGradient":"202B42","__Designer.Background.ImageTransparency":0,"__Designer.Colors.hoveredOptionTop":"4885A0","__Designer.Colors.elementText":"7692B8","__Designer.Colors.unhoveredOptionBottom":"5471C4"}]]
})

--// Tabs

local SettingsTab = MainFrame:CreateTab({
	Name = "AIMBOT--"
})

local FOVSettingsTab = MainFrame:CreateTab({
	Name = "FOV CONFIGS--"
})

local FunctionsTab = MainFrame:CreateTab({
	Name = "DA HOOD.copys"
})


local PVPTab = MainFrame:CreateTab({
	Name = "soon..."
})



--// Settings - Sections

local Values = SettingsTab:CreateSection({
	Name = "Values"
})

local Checks = SettingsTab:CreateSection({
	Name = "Checks"
})

local ThirdPerson = SettingsTab:CreateSection({
	Name = "Third Person Mode?"
})

--// FOV Settings - Sections

local FOV_Values = FOVSettingsTab:CreateSection({
	Name = "Values"
})

local FOV_Appearance = FOVSettingsTab:CreateSection({
	Name = "Appearance"
})

--// Functions - Sections

local FunctionsSection = FunctionsTab:CreateSection({
	Name = "Functions"
})


local PVPSection = FunctionsTab:CreateSection({
	Name = "legit pvp"
})
--// Settings / Values

Values:AddToggle({
	Name = "Enabled",
	Value = Settings.Enabled,
	Callback = function(New, Old)
		Settings.Enabled = New
	end
}).Default = Settings.Enabled

Values:AddToggle({
	Name = "Toggle",
	Value = Settings.Toggle,
	Callback = function(New, Old)
		Settings.Toggle = New
	end
}).Default = Settings.Toggle

Settings.LockPart = Parts[1]; Values:AddDropdown({
	Name = "Lock Part",
	Value = Parts[1],
	Callback = function(New, Old)
		Settings.LockPart = New
	end,
	List = Parts,
	Nothing = "Head"
}).Default = Parts[1]

Values:AddTextbox({ -- Using a Textbox instead of a Keybind because the UI Library doesn't support Mouse inputs like Left Click / Right Click...
	Name = "Hotkey",
	Value = Settings.TriggerKey,
	Callback = function(New, Old)
		Settings.TriggerKey = New
	end
}).Default = Settings.TriggerKey

--[[
Values:AddKeybind({
	Name = "Hotkey",
	Value = Settings.TriggerKey,
	Callback = function(New, Old)
		Settings.TriggerKey = stringmatch(tostring(New), "Enum%.[UserInputType]*[KeyCode]*%.(.+)")
	end,
}).Default = Settings.TriggerKey
]]




Values:AddSlider({
	Name = "Sensitivity",
	Value = Settings.Sensitivity,
	Callback = function(New, Old)
		Settings.Sensitivity = New
	end,
	Min = 0,
	Max = 1,
	Decimals = 2
}).Default = Settings.Sensitivity

--// Settings / Checks

Checks:AddToggle({
	Name = "Team Check",
	Value = Settings.TeamCheck,
	Callback = function(New, Old)
		Settings.TeamCheck = New
	end
}).Default = Settings.TeamCheck

Checks:AddToggle({
	Name = "Wall Check",
	Value = Settings.WallCheck,
	Callback = function(New, Old)
		Settings.WallCheck = New
	end
}).Default = Settings.WallCheck

Checks:AddToggle({
	Name = "Alive Check",
	Value = Settings.AliveCheck,
	Callback = function(New, Old)
		Settings.AliveCheck = New
	end
}).Default = Settings.AliveCheck

--// Settings / ThirdPerson

ThirdPerson:AddToggle({
	Name = "Enable Third Person",
	Value = Settings.ThirdPerson,
	Callback = function(New, Old)
		Settings.ThirdPerson = New
	end
}).Default = Settings.ThirdPerson

ThirdPerson:AddSlider({
	Name = "Sensitivity",
	Value = Settings.ThirdPersonSensitivity,
	Callback = function(New, Old)
		Settings.ThirdPersonSensitivity = New
	end,
	Min = 0.1,
	Max = 5,
	Decimals = 1
}).Default = Settings.ThirdPersonSensitivity

--// FOV Settings / Values
 
FOV_Values:AddToggle({
	Name = "Enabled",
	Value = FOVSettings.Enabled,
	Callback = function(New, Old)
		FOVSettings.Enabled = New
	end
}).Default = FOVSettings.Enabled

FOV_Values:AddToggle({
	Name = "Visible",
	Value = FOVSettings.Visible,
	Callback = function(New, Old)
		FOVSettings.Visible = New
	end
}).Default = FOVSettings.Visible

FOV_Values:AddSlider({
	Name = "Amount",
	Value = FOVSettings.Amount,
	Callback = function(New, Old)
		FOVSettings.Amount = New
	end,
	Min = 10,
	Max = 300
}).Default = FOVSettings.Amount

--// FOV Settings / Appearance

FOV_Appearance:AddToggle({
	Name = "Filled",
	Value = FOVSettings.Filled,
	Callback = function(New, Old)
		FOVSettings.Filled = New
	end
}).Default = FOVSettings.Filled

FOV_Appearance:AddSlider({
	Name = "Transparency",
	Value = FOVSettings.Transparency,
	Callback = function(New, Old)
		FOVSettings.Transparency = New
	end,
	Min = 0,
	Max = 1,
	Decimal = 1
}).Default = FOVSettings.Transparency

FOV_Appearance:AddSlider({
	Name = "Sides",
	Value = FOVSettings.Sides,
	Callback = function(New, Old)
		FOVSettings.Sides = New
	end,
	Min = 3,
	Max = 60
}).Default = FOVSettings.Sides

FOV_Appearance:AddSlider({
	Name = "Thickness",
	Value = FOVSettings.Thickness,
	Callback = function(New, Old)
		FOVSettings.Thickness = New
	end,
	Min = 1,
	Max = 50
}).Default = FOVSettings.Thickness

FOV_Appearance:AddColorpicker({
	Name = "Color",
	Value = FOVSettings.Color,
	Callback = function(New, Old)
		FOVSettings.Color = New
	end
}).Default = FOVSettings.Color

FOV_Appearance:AddColorpicker({
	Name = "Locked Color",
	Value = FOVSettings.LockedColor,
	Callback = function(New, Old)
		FOVSettings.LockedColor = New
	end
}).Default = FOVSettings.LockedColor


FunctionsSection:AddButton({
	Name = "BOX ESP",
	Callback = function()
-- Services
local RunService = game:GetService("RunService");
local PlayersService = game:GetService("Players");

-- Variables
local Camera = workspace.CurrentCamera;
local LastPos;
local Lines = {};
local Quads = {};

-- Functions
local function HasCharacter(Player)
    return Player.Character and Player.Character:FindFirstChild("HumanoidRootPart");
end;

local function DrawQuad(PosA, PosB, PosC, PosD)
    local PosAScreen, PosAVisible = Camera:WorldToViewportPoint(PosA);
    local PosBScreen, PosBVisible = Camera:WorldToViewportPoint(PosB);
    local PosCScreen, PosCVisible = Camera:WorldToViewportPoint(PosC);
    local PosDScreen, PosDVisible = Camera:WorldToViewportPoint(PosD);

    if (not PosAVisible and not PosBVisible and not PosCVisible and not PosDVisible) then return; end;

    local PosAVec = Vector2.new(PosAScreen.X, PosAScreen.Y);
    local PosBVec = Vector2.new(PosBScreen.X, PosBScreen.Y);
    local PosCVec = Vector2.new(PosCScreen.X, PosCScreen.Y);
    local PosDVec = Vector2.new(PosDScreen.X, PosDScreen.Y);

    local Quad = Drawing.new("Quad");
        Quad.Thickness = .5;
        Quad.Color = Color3.fromRGB(255, 255, 255);
        Quad.Transparency = .25;
        Quad.ZIndex = 1;
        Quad.Filled = true
        Quad.Visible = true;

        Quad.PointA = PosAVec;
        Quad.PointB = PosBVec;
        Quad.PointC = PosCVec;
        Quad.PointD = PosDVec;

    table.insert(Quads, Quad)
end

local function DrawLine(From, To)
    local FromScreen, FromVisible = Camera:WorldToViewportPoint(From);
    local ToScreen, ToVisible = Camera:WorldToViewportPoint(To);

    if (not FromVisible and not ToVisible) then return; end;

    local FromPos = Vector2.new(FromScreen.X, FromScreen.Y);
    local ToPos = Vector2.new(ToScreen.X, ToScreen.Y);

    local Line = Drawing.new("Line");
        Line.Thickness = 1;
        Line.From = FromPos
        Line.To = ToPos
        Line.Color = Color3.fromRGB(255, 255, 255);
        Line.Transparency = 1;
        Line.ZIndex = 1;
        Line.Visible = true;

    table.insert(Lines, Line)
end

-- Thank you Nahida#5000 for this function (GetCorners = GetVertices)
local function GetCorners(Part)
    local CF, Size, Corners = Part.CFrame, Part.Size / 2, {};
    for X = -1, 1, 2 do for Y = -1, 1, 2 do for Z = -1, 1, 2 do
        Corners[#Corners+1] = (CF * CFrame.new(Size * Vector3.new(X, Y, Z))).Position;      
    end; end; end;
    return Corners;
end;

local function DrawEsp(Player)
    local HRP = Player.Character.HumanoidRootPart;

    -- Constructing the 3d box.
    local CubeVertices = GetCorners({CFrame = HRP.CFrame * CFrame.new(0, -0.5, 0), Size = Vector3.new(3, 5, 3)});

    -- Drawing the 3d box.
        -- Bottom face:
        DrawLine(CubeVertices[1], CubeVertices[2]);
        DrawLine(CubeVertices[2], CubeVertices[6]);
        DrawLine(CubeVertices[6], CubeVertices[5]);
        DrawLine(CubeVertices[5], CubeVertices[1]);

        DrawQuad(CubeVertices[1], CubeVertices[2], CubeVertices[6], CubeVertices[5]);
       
        -- Side faces:
        DrawLine(CubeVertices[1], CubeVertices[3]);
        DrawLine(CubeVertices[2], CubeVertices[4]);
        DrawLine(CubeVertices[6], CubeVertices[8]);
        DrawLine(CubeVertices[5], CubeVertices[7]);

        DrawQuad(CubeVertices[2], CubeVertices[4], CubeVertices[8], CubeVertices[6]);
        DrawQuad(CubeVertices[1], CubeVertices[2], CubeVertices[4], CubeVertices[3]);
        DrawQuad(CubeVertices[1], CubeVertices[5], CubeVertices[7], CubeVertices[3]);
        DrawQuad(CubeVertices[5], CubeVertices[7], CubeVertices[8], CubeVertices[6]);

        -- Top face:
        DrawLine(CubeVertices[3], CubeVertices[4]);
        DrawLine(CubeVertices[4], CubeVertices[8]);
        DrawLine(CubeVertices[8], CubeVertices[7]);
        DrawLine(CubeVertices[7], CubeVertices[3]);
       
        DrawQuad(CubeVertices[3], CubeVertices[4], CubeVertices[8], CubeVertices[7]);
end;

local function BoxEsp()
    local Players = PlayersService:GetPlayers();

    for i = 1, #Lines do
        local Line = rawget(Lines, i);
        if (Line) then Line:Remove(); end;
    end;

    Lines = {};

    for i = 1, #Quads do
        local Quad = rawget(Quads, i);
        if (Quad) then Quad:Remove(); end;
    end;

    Quads = {};

    for i = 1, #Players do
        local Player = rawget(Players, i);
        if HasCharacter(Player) then
            DrawEsp(Player);
        end;
    end;
end;

-- Main
RunService.RenderStepped:Connect(BoxEsp);
	end
})


FunctionsSection:AddButton({
	Name = "distance esp",
	Callback = function()


--

--dear sigma yuri user its too hard to make a distance esp so who every made this credits to you


---this also may not apear on some players i am not sure why
local c = workspace.CurrentCamera
local ps = game:GetService("Players")
local lp = ps.LocalPlayer
local rs = game:GetService("RunService")

local function esp(p, cr)
    local h = cr:WaitForChild("Humanoid")
    local hrp = cr:WaitForChild("HumanoidRootPart") -- HumanoidRootPart for position

    local textLabel = Drawing.new("Text")
    textLabel.Visible = false
    textLabel.Center = true
    textLabel.Outline = false
    textLabel.Font = 6
    textLabel.Size = 11
    textLabel.Color = Color3.new(1, 1, 1) -- Beyaz ("Distance:")

    local distanceLabel = Drawing.new("Text")
    distanceLabel.Visible = false
    distanceLabel.Center = true
    distanceLabel.Outline = false
    distanceLabel.Font = 4
    distanceLabel.Size = 11
    distanceLabel.Color = Color3.new(1, 0.5, 0) -- Turuncu (mesafe)

    local conection
    local conection2
    local conection3

    local function dc()
        textLabel.Visible = false
        textLabel:Remove()
        distanceLabel.Visible = false
        distanceLabel:Remove()
        if conection then
            conection:Disconnect()
            conection = nil
        end
        if conection2 then
            conection2:Disconnect()
            conection2 = nil
        end
        if conection3 then
            conection3:Disconnect()
            conection3 = nil
        end
    end

    conection2 = cr.AncestryChanged:Connect(function(_, parent)
        if not parent then
            dc()
        end
    end)

    conection3 = h.HealthChanged:Connect(function(v)
        if (v <= 0) or (h:GetState() == Enum.HumanoidStateType.Dead) then
            dc()
        end
    end)

    conection = rs.RenderStepped:Connect(function()
        local hrp_pos, hrp_onscreen = c:WorldToViewportPoint(hrp.Position)
        if hrp_onscreen then
            -- Mesafeyi hesapla
            local distance = (lp.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
            -- "Distance:" yazısını ayarla
            textLabel.Position = Vector2.new(hrp_pos.X, hrp_pos.Y + 39) -- 39 piksel aşağıya
            textLabel.Text = "Distance:"
            textLabel.Visible = true

            -- Mesafe değerini ayarla ve "Distance:" yazısının yanına yerleştir
            distanceLabel.Position = Vector2.new(hrp_pos.X + textLabel.TextBounds.X + 5, hrp_pos.Y + 39) -- 39 piksel aşağıya
            distanceLabel.Text = string.format("%.1f", distance) -- Mesafeyi yuvarla
            distanceLabel.Visible = true
        else
            textLabel.Visible = false
            distanceLabel.Visible = false
        end
    end)
end

local function p_added(p)
    if p.Character then
        esp(p, p.Character)
    end
    p.CharacterAdded:Connect(function(cr)
        esp(p, cr)
    end)
end

for i, p in next, ps:GetPlayers() do
    if p ~= lp then
        p_added(p)
    end
end

ps.PlayerAdded:Connect(p_added)
	end
})



---------------------

FunctionsSection:AddButton({
	Name = "spam hitbox = fps drop",
	Callback = function()

	end
})

FunctionsSection:AddButton({
	Name = "hitbox reset[glitchy]",
	Callback = function()
_G.HeadSize = 1 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 10 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = true v.Character.Head.Massless = true end) end end end end)
	end
})



FunctionsSection:AddButton({
	Name = "hitbox extender [15]",
	Callback = function()
_G.HeadSize = 15 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})



FunctionsSection:AddButton({
	Name = "hitbox extender [20]",
	Callback = function()
_G.HeadSize = 20 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})


FunctionsSection:AddButton({
	Name = "HOOD CUSTOM legit",
	Callback = function()
_G.HeadSize = 1.3 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})


FunctionsSection:AddButton({
	Name = "HOOD CUSTOMS",



	-----------------
	Callback = function()
local function NewLine(thickness, color)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    return line
end

local function HealthBar(plr)
    local library = {
        -- Sağlık barı çizgileri
        healthbar = NewLine(3, Color3.fromRGB(1, 0, 0)),  -- Arka plan çizgisi
        greenhealth = NewLine(1.5, Color3.fromRGB(105, 255, 62))  -- Sağlık durumu çizgisi (yeşil)
    }

    -- Health bar'ı sürekli güncelleyen fonksiyon
    local function Updater()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                local HumPos, OnScreen = game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                if OnScreen then
                    local head = game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(plr.Character.Head.Position)
                    local DistanceY = math.clamp((Vector2.new(head.X, head.Y) - Vector2.new(HumPos.X, HumPos.Y)).magnitude, 2, math.huge)

                    -- Barın boyutunu hesaplama
                    local d = (Vector2.new(HumPos.X - DistanceY, HumPos.Y - DistanceY*2) - Vector2.new(HumPos.X - DistanceY, HumPos.Y + DistanceY*2)).magnitude
                    local healthoffset = plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth * d

                    -- Sağlık barını güncelleme
                    library.greenhealth.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                    library.greenhealth.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2 - healthoffset)

                    library.healthbar.From = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y + DistanceY*2)
                    library.healthbar.To = Vector2.new(HumPos.X - DistanceY - 4, HumPos.Y - DistanceY*2)

                    -- Sağlık çubuğunun rengini ayarlama (Kırmızıdan Yeşile geçiş)
                    local green = Color3.fromRGB(0, 255, 0)
                    local red = Color3.fromRGB(255, 0, 0)
                    library.greenhealth.Color = red:lerp(green, plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)

                    -- Sağlık çubuğunu görünür yapma
                    library.greenhealth.Visible = true
                    library.healthbar.Visible = true
                else
                    -- Eğer oyuncu ekran dışında ise, sağlık çubuğunu gizle
                    library.greenhealth.Visible = false
                    library.healthbar.Visible = false
                end
            else
                -- Eğer oyuncu öldü veya yoksa, sağlık çubuğunu gizle
                library.greenhealth.Visible = false
                library.healthbar.Visible = false
            end
        end)
    end

    -- Çubuğu başlatmak için Updater fonksiyonunu çalıştır
    coroutine.wrap(Updater)()
end

-- Mevcut oyuncuları kontrol et
for i, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= game:GetService("Players").LocalPlayer.Name then
        coroutine.wrap(HealthBar)(v)
    end
end

-- Yeni oyuncular eklenince sağlık çubuğunu başlat
game.Players.PlayerAdded:Connect(function(newplr)
    if newplr.Name ~= game:GetService("Players").LocalPlayer.Name then
        coroutine.wrap(HealthBar)(newplr)
    end
end)
	------
_G.HeadSize = 2 _G.Disabled = true game:GetService('RunService').RenderStepped:connect(function() if _G.Disabled then for i,v in next, game:GetService('Players'):GetPlayers() do if v.Name ~= game:GetService('Players').LocalPlayer.Name then pcall(function() v.Character.Head.Size = Vector3.new(_G.HeadSize,_G.HeadSize,_G.HeadSize) v.Character.Head.Transparency = 5 v.Character.Head.BrickColor = BrickColor.new("Yellow") v.Character.Head.Material = "Neon" v.Character.Head.CanCollide = false v.Character.Head.Massless = true end) end end end end)
	end
})

FunctionsSection:AddButton({
	Name = "BYPASSED FLY V [cframe]",
Callback = function()
local Players = game:GetService("Players");
local UserInputService = game:GetService("UserInputService");
local RunService = game:GetService("RunService")

local Maid = loadstring(game:HttpGet('https://raw.githubusercontent.com/Quenty/NevermoreEngine/main/src/maid/src/Shared/Maid.lua'))()

shared.Maid = shared.Maid or Maid.new(); local Maid = shared.Maid; Maid:DoCleaning();
shared.Active = true;

local Ignore = false

local Offset = 1.34;

local Camera = workspace.CurrentCamera;

local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait();
local Character = LocalPlayer.Character or LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait();

local CurrentPoint = Character:GetPivot();

local task = table.clone(task);

local OldDelay = task.delay;

function task.delay(Time, Function)
    local Enabled = true;
    
    OldDelay(Time, function()
        if Enabled then
            Function();
        end
    end)
    
    return {
        Cancel = function()
            Enabled = false;
        end;
        Activate = function()
            Enabled = false
            Function()
        end
    }
end
local wait = task.wait;

local function StopVelocity()
    local HumanoidRootPart = Character and Character:FindFirstChild("HumanoidRootPart"); if not HumanoidRootPart then return end;
    
    HumanoidRootPart.Velocity = Vector3.zero;
end

Maid:GiveTask(LocalPlayer.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
end))

Maid:GiveTask(RunService.Stepped:Connect(function()
    if shared.Active then
        StopVelocity();
        local CameraCFrame = Camera.CFrame
        
        CurrentPoint = CFrame.new(CurrentPoint.Position, CurrentPoint.Position + CameraCFrame.LookVector)
        Character:PivotTo(CurrentPoint);
    end
end))

local CurrentTask = nil;

local KeyBindStarted = {
    [Enum.KeyCode.Q] = {
        ["FLY_UP"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.E) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, Offset, 0)
            end
        end;
    };
    [Enum.KeyCode.E] = {
        ["FLY_DOWN"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.Q) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, -Offset, 0)
            end
        end;
    };
    [Enum.KeyCode.W] = {
        ["FLY_FORWARD"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.W) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, 0, -Offset)
            end
        end;
    };
    [Enum.KeyCode.S] = {
        ["FLY_BACK"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.S) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(0, 0, Offset)
            end
        end;
    };
    [Enum.KeyCode.A] = {
        ["FLY_LEFT"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.A) do
                RunService.Stepped:Wait()
                if Ignore then continue end;

                CurrentPoint = CurrentPoint * CFrame.new(-Offset, 0, 0)
            end
        end;
    };
    [Enum.KeyCode.D] = {
        ["FLY_RIGHT"] = function()
            while UserInputService:IsKeyDown(Enum.KeyCode.D) do
                RunService.Stepped:Wait()
                if Ignore then continue end;
                
                CurrentPoint = CurrentPoint * CFrame.new(Offset, 0, 0)
            end
        end;
    };
    [Enum.KeyCode.Space] = {
        ["IGNORE_ON"] = function()
            Ignore = true
        end;
    };
    [Enum.KeyCode.V] = {
        ["TOGGLE"] = function()
            local Humanoid = Character:FindFirstChild("Humanoid") if not Humanoid then return end;
            local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart") if not HumanoidRootPart then return end;
            
            if not shared.Active then
                CurrentPoint = Character:GetPivot();
            else
                if CurrentTask then
                    CurrentTask:Activate()
                end
            
                StopVelocity();
                
                Character:PivotTo(CFrame.new(Character:GetPivot().Position))
                
                local RunServiceSignal = RunService.Stepped:Connect(function()
                    local AssemblyAngularVelocity = HumanoidRootPart.AssemblyAngularVelocity;
                    
                    if AssemblyAngularVelocity.X > 7 
                    or AssemblyAngularVelocity.Y > 7
                    or AssemblyAngularVelocity.Z > 7  then
                         Character:PivotTo(CFrame.new(Character:GetPivot().Position))
                    end
                end)
                
                CurrentTask = task.delay(10, function()
                    RunServiceSignal:Disconnect()
                end)
                
                Maid:GiveTask(RunServiceSignal)
            end
            
            shared.Active = not shared.Active
        end;
    }
}

local KeyBindEnded = {
    [Enum.KeyCode.Space] = {
        ["IGNORE_OFF"] = function()
            Ignore = false
        end;
    };
}

Maid:GiveTask(UserInputService.InputBegan:Connect(function(Input, GameProcessedEvent)
	if not GameProcessedEvent then
		if Input.UserInputType == Enum.UserInputType.Keyboard and KeyBindStarted[Input.KeyCode] then
			for _, Function in pairs(KeyBindStarted[Input.KeyCode]) do
				task.spawn(Function)
			end
		elseif KeyBindStarted[Input.UserInputType] then
			for _, Function in pairs(KeyBindStarted[Input.UserInputType]) do
                task.spawn(Function)
			end
		end
	end
end))

Maid:GiveTask(UserInputService.InputEnded:Connect(function(Input, GameProcessedEvent)
	if not GameProcessedEvent then
		if Input.UserInputType == Enum.UserInputType.Keyboard and KeyBindEnded[Input.KeyCode] then
			for _, Function in pairs(KeyBindEnded[Input.KeyCode]) do
				task.spawn(Function)
			end
		elseif KeyBindEnded[Input.UserInputType] then
			for _, Function in pairs(KeyBindEnded[Input.UserInputType]) do
                task.spawn(Function)
			end
		end
	end
end))



	end
})

FunctionsSection:AddButton({
	Name = "speedhack  Q [velocity]",
	Callback = function()
local speedhack = false

function onKeyPress(inputObject, gameProcessedEvent)
    if inputObject.KeyCode == Enum.KeyCode.Q and gameProcessedEvent == false then
     if speedhack == false then
       speedhack = true

     elseif speedhack == true then
       speedhack = false
    
       
     end
   end
end
 
game:GetService("UserInputService").InputBegan:connect(onKeyPress)


while wait() do
    if speedhack == true then
     game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame.lookVector * 80
    end
    
end




	end
})
----------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------



FunctionsSection:AddButton({
	Name = "HOODCUSTOMS LOCK[v1]",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.04
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})





--------------------------------------------------------

FunctionsSection:AddButton({
	Name = "AIMLOCK",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.02
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})








---------------












FunctionsSection:AddButton({
	Name = "1V1 HOOD",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = .115
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})






----





FunctionsSection:AddButton({
	Name = "DAHOOD",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = .1243
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})





FunctionsSection:AddButton({
	Name = "HOODCUSTOMS LOCK[v2]",
	Callback = function()
--sigma yuri aimlock

getgenv().Prediction = 0.06
getgenv().AimPart = "Head"
getgenv().Key = "C"
getgenv().DisableKey = "P"

getgenv().FOV = true
getgenv().ShowFOV = true
getgenv().FOVSize = 50

--// Variables (Service)

local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")
local SG = game:GetService("StarterGui")

--// Variables (regular)

local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local AimlockState = true
local Locked
local Victim

local SelectedKey = getgenv().Key
local SelectedDisableKey = getgenv().DisableKey

--// Notification function

function Notify(tx)
    SG:SetCore("SendNotification", {
        Title = "Enabled ✔ | SIGMA YURI[v3]",
        Text = tx,
        Duration = 5
    })
end

--// Check if aimlock is loaded

if getgenv().Loaded == true then
    Notify("Aimlock is already loaded!")
    return
end

getgenv().Loaded = true

--// FOV Circle

local fov = Drawing.new("Circle")
fov.Filled = false
fov.Transparency = 1
fov.Thickness = 1
fov.Color = Color3.fromRGB(255, 5, 100)
fov.NumSides = 3

--// Functions

function update()
    if getgenv().FOV == true then
        if fov then
            fov.Radius = getgenv().FOVSize * 2
            fov.Visible = getgenv().ShowFOV
            fov.Position = Vector2.new(Mouse.X, Mouse.Y + GetGuiInset(GS).Y)

            return fov
        end
    end
end

function WTVP(arg)
    return Camera:WorldToViewportPoint(arg)
end

function WTSP(arg)
    return Camera.WorldToScreenPoint(Camera, arg)
end

function getClosest()
    local closestPlayer
    local shortestDistance = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        local notKO = v.Character:WaitForChild("BodyEffects")["K.O"].Value ~= true
        local notGrabbed = v.Character:FindFirstChild("GRABBING_COINSTRAINT") == nil
        
        if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild(getgenv().AimPart) and notKO and notGrabbed then
            local pos = Camera:WorldToViewportPoint(v.Character.PrimaryPart.Position)
            local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).magnitude
            
            if (getgenv().FOV) then
                if (fov.Radius > magnitude and magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            else
                if (magnitude < shortestDistance) then
                    closestPlayer = v
                    shortestDistance = magnitude
                end
            end
        end
    end
    return closestPlayer
end
 
--// Checks if key is down

Mouse.KeyDown:Connect(function(k)
    SelectedKey = SelectedKey:lower()
    SelectedDisableKey = SelectedDisableKey:lower()
    if k == SelectedKey then
        if AimlockState == true then
            Locked = not Locked
            if Locked then
                Victim = getClosest()

                Notify("Locked onto: "..tostring(Victim.Character.Humanoid.DisplayName))
            else
                if Victim ~= nil then
                    Victim = nil

                    Notify("Unlocked!")
                end
            end
        else
            Notify("Aimlock is not enabled!")
        end
    end
    if k == SelectedDisableKey then
        AimlockState = not AimlockState
    end
end)

--// Loop update FOV and loop camera lock onto target

RS.RenderStepped:Connect(function()
    update()
    if AimlockState == true then
        if Victim ~= nil then
            Camera.CFrame = CFrame.new(Camera.CFrame.p, Victim.Character[getgenv().AimPart].Position + Victim.Character[getgenv().AimPart].Velocity*getgenv().Prediction)
        end
    end
end)
	while wait() do
        if getgenv().AutoPrediction == true then
        local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local split = string.split(pingvalue,'(')
        local ping = tonumber(split[1])
            if ping < 252325 then
            getgenv().Prediction = 1.4
        elseif ping < 2199999995 then
            getgenv().Prediction = 1.2
	    elseif ping < 29999905 then
            getgenv().Prediction = 1.0
	    elseif ping < 1999990 then
            getgenv().Prediction = 0.10
        elseif ping < 18999990 then
            getgenv().Prediction = 0.12
	    elseif ping < 199999970 then
            getgenv().Prediction = 0.15
	    elseif ping < 19999960 then
            getgenv().Prediction = 0.18
	    elseif ping < 1999950 then
            getgenv().Prediction = 0.110
        elseif ping < 19999940 then
            getgenv().Prediction = 0.113
        elseif ping < 19999999930 then
            getgenv().Prediction = 0.116
        elseif ping < 999999120 then
            getgenv().Prediction = 0.120
        elseif ping < 999999110 then
            getgenv().Prediction = 0.124
        elseif ping < 199999905 then
            getgenv().Prediction = 0.127
        elseif ping < 99999990 then
            getgenv().Prediction = 0.130
        elseif ping < 999999980 then
            getgenv().Prediction = 0.133
        elseif ping < 799999990 then
            getgenv().Prediction = 0.136
        elseif ping < 99999960 then
            getgenv().Prediction = 0.15038
        elseif ping < 59999990 then
            getgenv().Prediction = 0.15038
        elseif ping < 99999940 then
            getgenv().Prediction = 0.145
        elseif ping < 3999990 then
            getgenv().Prediction = 0.155
        elseif ping < 29999990 then
            getgenv().Prediction = 0.157
        end
        end
	end
	end
})

--the section below is for rivals btw

---------------------------------------------------------------------------------------------------
